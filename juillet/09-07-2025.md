## ‚úÖ T√¢ches effectu√©es

- Dto des `link`
	
- Cr√©ation d'un nouveau endpoint pour le filtre sur `isAvailable`
	
- Infinite scroll `Links`
	
- Suppression automatique des `MailRequest` apr√®s `X` jours
	

---

## üìö Connaissances acquises

- 
	

---

## üêû Probl√®mes rencontr√©s

- 
	

---

## üîú √Ä faire demain

- `Change-password` (revoir le mail)
	

---

## üß© Notes / Code

```java
@GetMapping("/filter")  
public ResponseEntity<PageDto<LinkResponseDto>> getLinksByAvailability  
    (@RequestParam boolean available, @PageableDefault(size = 25) Pageable pageable) {  
  return ResponseEntity.ok(linkService.findAllByAvailability(available, pageable));  
}

@GetMapping  
public ResponseEntity<PageDto<LinkResponseDto>> getLinks(@PageableDefault(size = 25) Pageable pageable) {  
    return ResponseEntity.ok(linkService.getAllLinks(pageable));  
}
```

```java
@Scheduled(cron = "0 0 13 * * *")  
@Transactional  
public void deleteOldMails () {  
  LocalDateTime cutoff = LocalDateTime.now().minusDays(purgeCutoffDays);  
  int deleted = mailRepository.deleteAllMailRequestByLastAttemptBefore(cutoff);  
  logger.info("Deleted {} mails request which were older than {} days", deleted, purgeCutoffDays);  
}
```

```java
public class LinkMapper {  
  
  public static LinkResponseDto toLinkResponseDto(Link link) {  
    return new LinkResponseDto(  
        link.getId(),  
        link.getLink(),  
        link.isAvailable(),  
        link.getLastReset()  
    );  
  }  
  
  public static Link toLink(LinkCreateDto linkCreateDto) {  
    Link link = new Link();  
    link.setLink(linkCreateDto.url());  
    link.setAvailable(true);  
    link.setLastReset(LocalDateTime.now());  
    return link;  
  }  
  
  public static List<LinkResponseDto> toPageContent(Page<Link> page) {  
    return page.stream()  
        .map(LinkMapper::toLinkResponseDto)  
        .toList();  
  }  
}
```

```ts
loadMore(reset: boolean = false, available?: boolean) {  
  if (this.isLoading || (this.isLastPage && !reset)) {  
    return;  
  }  
  if (reset) {  
    this.currentPage = 0;  
    this.isLastPage = false;  
    this.allLinks = [];  
  }  
  this.isLoading = true;  
  
  const fetch$ = (available === undefined)  
    ? this.linkService.getAllLinks(this.currentPage, this.pageSize)  
    : this.linkService.getLinkByAvailability(available, this.currentPage, this.pageSize);  
  
  fetch$.subscribe({  
    next: (page: Page<Link>) => {  
      this.allLinks = [...this.allLinks, ...page.content];  
      this.currentPage++;  
      this.isLastPage = page.last;  
      this.isLoading = false;  
      this.linkCount = page.totalElements;  
    },  
    error: (err) => {  
      this.isLoading = false;  
      this.errorHandler.handleError(err.error.message);  
    }  
  });  
  this.applyFilters();  
}

onScroll(event: Event) {  
  const el = event.target as HTMLElement;  
  const threshold = 100;  
  
  const isNearBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - threshold;  
  if (!isNearBottom) return;  
  
  const filter =  
    this.showUnavailable ? false :  
      this.showAvailable ? true :  
        undefined;  
  
  this.loadMore(false, filter);  
}
```