## âœ… TÃ¢ches effectuÃ©es

- Ajout d'un champ meeting_id dans `Link`

- Taille par dÃ©faut des `Pageable` dans la config
	
- Algo de match -> match si u1.role != u2.role
	
- Update des `Page<T>` lorsque le nombre d'objet `<T>` dans la page est faible
	

---

## ðŸ“š Connaissances acquises

- Transitions front avec `withViewTransitions()`
	

---

## ðŸž ProblÃ¨mes rencontrÃ©s

- `provideRouter(routes, withViewTransitions())` permet de faire des transitions mais les transitions entre page essayÃ© font mal aux yeux
	
- La suppression pour `50 000 meetings` est beaucoup trop lente / ne marche pas (trop lourd) Ã  cause des triggers
	

---

## ðŸ”œ Ã€ faire demain

- Message format incorrecte Ã  l'ajout d'un lien
	
- Message de chargement lors de l'organize
	
- Delete User -> Delete Meeting -> Reset Link Activity (Refactor pour ne plus avoir `@Lazy`)
	
- Opti la suppression et la crÃ©ation de meeting
	
- Pas besoin de is_available dans Link, on se base sur meeting_id et donc pas de manual reset on delete et donc meilleur perf et pas d'inclusions circulaire
	

---

## ðŸ§© Notes / Code

```java
  
@Autowired  
public UserServiceImpl (UserRepository userRepository, @Lazy MeetingService meetingService) {  
  this.userRepository = userRepository;  
  this.meetingService = meetingService;  
}

@Override  
@Transactional  
public void deleteUserById (Long id) {  
  User user = userRepository.findById(id)  
      .orElseThrow(() -> new EntityNotFoundException("User with id " + id + " not found."));  
  if (user.getMeetingId() != null && user.getMeetingId() != 0L) {  
    meetingService.deleteMeetingById(user.getMeetingId());  
  }  
  userRepository.delete(user);  
}
```
