## ‚úÖ T√¢ches effectu√©es

- Fonction utilitaire `temporaryMessageUtils` pour les messages temporaires avec `clearTimeout(id)` pour reset le `timeout`
	
- Fonction utilitaire `pageLoader<T>` pour √©viter la duplication de code du chargement de page entre les diff√©rents composants (`UserListComponent`, `MeetingListComponent`, `LinkListComponent`)
	
- Fonctions utilitaires `deleteUtils<T, C>` et `deleteByIdUtils<T, C>` pour √©viter la duplication de code de suppression des `items<T>` entre les diff√©rents composants
	
- Refactorisation du `fetch` et `deleteById` du `UserListComponent` en gardant des `BehaviorSubject` pour la fluidit√© et la synchronisation des affichages
	

---

## üìö Connaissances acquises

- 
	

---

## üêû Probl√®mes rencontr√©s

- L'utilisation de la fonction utilitaire pour supprimer par `id` n'est pas utilisable pour les `users` car il faudrait faire un appel pour `allUsers` et un appel pour `usersNoMeeting`. Sachant que le premier appel va effectuer la suppression, le deuxi√®me appel va renvoyer une erreur car cet `id` n'existe plus. On utilise donc des `BehaviorSubject` pour avoir une suppression fluide et concurrente entre les deux containers.
	

---

## üîú √Ä faire demain

- Finir la refacto de `UserListComponent` avec les m√©thodes utilitaires
	
- Feedback durant `OrganizeMeetings` pour ne pas avoir simplement une attente (+/- longue en fonction du nombre de `Users`)
	

---

## üß© Notes / Code

```ts
import {Page} from '../models/page';  
import {Observable} from 'rxjs';  
import {ErrorHandlingService} from '../services/error-handling.service';  
import {MessageUtils, temporaryMessageUtils} from './temporary-message.utils';  
  
export interface PageProperties<T> {  
  currentPage: number;  
  container: T[];  
  isLastPage: boolean;  
  isLoading: boolean;  
  totalElements: number;  
}  
  
export function pageLoader<T>(  
  reset: boolean,  
  fetch$: Observable<Page<T>>,  
  pageProperties: PageProperties<T>,  
  errorHandler: ErrorHandlingService,  
  onLoad?: (items: T[]) => void,  
): void {  
  
  if (pageProperties.isLoading || (!reset && pageProperties.isLastPage)) {  
    return;  
  }  
  
  if (reset) {  
    pageProperties.container = [];  
    pageProperties.currentPage = 0;  
    pageProperties.isLastPage = false;  
  }  
  
  pageProperties.isLoading = true;  
  fetch$.subscribe({  
    next: (page: Page<T>) => {  
      pageProperties.currentPage++;  
      pageProperties.container = [...pageProperties.container, ...page.content];  
      pageProperties.isLastPage = page.last;  
      pageProperties.isLoading = false;  
      pageProperties.totalElements = page.totalElements;  
  
      if (onLoad) {  
        onLoad(pageProperties.container);  
      }  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
} 
  
  
export function deleteUtils<T, C>(  
  delete$: Observable<void>,  
  pageProperties: PageProperties<T>,  
  utils: MessageUtils<C>,  
  errorHandler: ErrorHandlingService,  
): void {  
  delete$.subscribe({  
    next: (res: any) => {  
      pageProperties.container = [];  
      pageProperties.currentPage = 0;  
      pageProperties.isLastPage = false;  
      pageProperties.isLoading = false;  
      pageProperties.totalElements = 0;  
      temporaryMessageUtils(utils, res.message);  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
}  
  
export function deleteByIdUtils<T extends { id: number }, C>(  
  delete$: Observable<void>,  
  reload: (reset: boolean) => void,  
  pageProperties: PageProperties<T>,  
  utils: MessageUtils<C>,  
  id: number,  
  errorHandler: ErrorHandlingService,  
): void {  
  delete$.subscribe({  
    next: (res: any) => {  
      const pageIsUnderfilled = pageProperties.container.length <= 1  
        && !pageProperties.isLastPage;  
      if (pageIsUnderfilled) {  
        reload(true);  
      } else {  
        pageProperties.container = pageProperties.container.filter(item => item.id !== id);  
        pageProperties.totalElements--;  
      }  
      temporaryMessageUtils(utils, res.message);  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
}
```

```ts
pagination: PageProperties<Meeting> = {  
  currentPage: 0,  
  container: [],  
  isLastPage: false,  
  isLoading: false,  
  totalElements: 0,  
}  
  
pageSize = 25;  
timeoutRef: { id: number } = {id: 0};  
  
constructor(private meetingService: MeetingService,  
            private errorHandler: ErrorHandlingService) {  
}  
  
loadMeetings(reset: boolean = false) {  
  pageLoader(  
    reset,  
    this.meetingService.getAllMeetings(this.pagination.currentPage, this.pageSize),  
    this.pagination,  
    this.errorHandler,  
  );  
}  
  
ngOnInit(): void {  
  this.loadMeetings(true);  
}  
  
filterMeetings(text: string) {  
  this.filter = text;  
  this.pagination.currentPage = 0;  
  
  pageLoader(  
    true,  
    this.meetingService.getMeetingFilteredByUsername(  
      this.filter, this.pagination.currentPage, this.pageSize  
    ),  
    this.pagination,  
    this.errorHandler  
  );  
}
```

```ts
timeoutRef: { id: number } = {id: 0};  
  
paginationAllUsers: PageProperties<UserResponseDto> = {  
  currentPage: 0,  
  container: [],  
  isLastPage: false,  
  isLoading: false,  
  totalElements: 0,  
};  
  
paginationUsersNoMeeting: PageProperties<UserResponseDto> = {  
  currentPage: 0,  
  container: [],  
  isLastPage: false,  
  isLoading: false,  
  totalElements: 0,  
}  
  
allUsers$ = new BehaviorSubject<UserResponseDto[]>([]);  
usersNoMeeting$ = new BehaviorSubject<UserResponseDto[]>([]);  
  
constructor(  
  private userService: UserService,  
  private router: Router,  
  private errorHandler: ErrorHandlingService  
) {  
}  
  
ngOnInit() {  
  this.fetchUsers(true);  
  this.fetchUsersWithoutMeeting(true);  
}  
  
fetchUsers(reset: boolean = false) {  
  pageLoader(  
    reset,  
    this.userService.getAllUsers(this.paginationAllUsers.currentPage, this.pageSize),  
    this.paginationAllUsers,  
    this.errorHandler,  
    users => this.allUsers$.next(users),  
  );  
}  
  
fetchUsersWithoutMeeting(reset: boolean = false) {  
  pageLoader(  
    reset,  
    this.userService.usersWithoutMeeting(this.paginationUsersNoMeeting.currentPage, this.pageSize),  
    this.paginationUsersNoMeeting,  
    this.errorHandler,  
    usersNoMeeting => this.usersNoMeeting$.next(usersNoMeeting)  
  );  
}
```