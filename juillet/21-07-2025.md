## ‚úÖ T√¢ches effectu√©es

- Fonction utilitaire `temporaryMessageUtils` pour les messages temporaires avec `clearTimeout(id)` pour reset le `timeout`
	
- Fonction utilitaire `pageLoader<T>` pour √©viter la duplication de code du chargement de page entre les diff√©rents composants (`UserListComponent`, `MeetingListComponent`, `LinkListComponent`)
	
- Fonctions utilitaires `deleteUtils<T, C>` et `deleteByIdUtils<T, C>` pour √©viter la duplication de code de suppression des `items<T>` entre les diff√©rents composants
	
- Refactorisation du `fetch` et `deleteById` du `UserListComponent` en gardant des `BehaviorSubject` pour la fluidit√© et la synchronisation des affichages
	

---

## üìö Connaissances acquises

- 
	

---

## üêû Probl√®mes rencontr√©s

- L'utilisation de la fonction utilitaire pour supprimer par `id` n'est pas utilisable pour les `users` car il faudrait faire un appel pour `allUsers` et un appel pour `usersNoMeeting`. Sachant que le premier appel va effectuer la suppression, le deuxi√®me appel va renvoyer une erreur car cet `id` n'existe plus. On utilise donc des `BehaviorSubject` pour avoir une suppression fluide et concurrente entre les deux containers.
	

---

## üîú √Ä faire demain

- Finir la refacto de `UserListComponent` avec les m√©thodes utilitaires
	
- Feedback durant `OrganizeMeetings` pour ne pas avoir simplement une attente (+/- longue en fonction du nombre de `Users`)
	

---

## üß© Notes / Code

```ts
import {Page} from '../models/page';  
import {Observable} from 'rxjs';  
import {ErrorHandlingService} from '../services/error-handling.service';  
import {MessageUtils, temporaryMessageUtils} from './temporary-message.utils';  
  
export interface PageProperties<T> {  
  currentPage: number;  
  container: T[];  
  isLastPage: boolean;  
  isLoading: boolean;  
  totalElements: number;  
}  
  
export function pageLoader<T>(  
  reset: boolean,  
  fetch$: Observable<Page<T>>,  
  pageProperties: PageProperties<T>,  
  errorHandler: ErrorHandlingService,  
): void {  
  
  if (pageProperties.isLoading || (!reset && pageProperties.isLastPage)) {  
    return;  
  }  
  
  if (reset) {  
    pageProperties.container = [];  
    pageProperties.currentPage = 0;  
    pageProperties.isLastPage = false;  
  }  
  
  pageProperties.isLoading = true;  
  fetch$.subscribe({  
    next: (page: Page<T>) => {  
      pageProperties.currentPage++;  
      pageProperties.container = [...pageProperties.container, ...page.content];  
      pageProperties.isLastPage = page.last;  
      pageProperties.isLoading = false;  
      pageProperties.totalElements = page.totalElements;  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
}  
  
  
export function deleteUtils<T, C>(  
  delete$: Observable<void>,  
  pageProperties: PageProperties<T>,  
  utils: MessageUtils<C>,  
  errorHandler: ErrorHandlingService,  
): void {  
  delete$.subscribe({  
    next: (res: any) => {  
      pageProperties.container = [];  
      pageProperties.currentPage = 0;  
      pageProperties.isLastPage = false;  
      pageProperties.isLoading = false;  
      pageProperties.totalElements = 0;  
      temporaryMessageUtils(utils, res.message);  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
}  
  
export function deleteByIdUtils<T extends { id: number }, C>(  
  delete$: Observable<void>,  
  reload: (reset: boolean) => void,  
  pageProperties: PageProperties<T>,  
  utils: MessageUtils<C>,  
  id: number,  
  errorHandler: ErrorHandlingService,  
): void {  
  delete$.subscribe({  
    next: (res: any) => {  
      const pageIsUnderfilled = pageProperties.container.length <= 1  
        && !pageProperties.isLastPage;  
      if (pageIsUnderfilled) {  
        reload(true);  
      } else {  
        pageProperties.container = pageProperties.container.filter(item => item.id !== id);  
        pageProperties.totalElements--;  
      }  
      temporaryMessageUtils(utils, res.message);  
    },  
    error: (err: any) => {  
      pageProperties.isLoading = false;  
      errorHandler.handleError(err.error.message);  
    }  
  })  
}
```
