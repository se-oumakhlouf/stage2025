## ‚úÖ T√¢ches effectu√©es

- Suppression du champ `Links.is_Available`, on se base uniquement sur `Link.meeting_id` dans le back et on envoie toujours le m√™me `LinkResponseDto` avec un boolean `isAvailable` :
	- Pas besoin d'exposer le `L.meeting_id` dans le front
	- Pas besoin de modifier la logique du front car la forme du `LinkResponseDto` ne change pas
	
- Ajouts d'indexes sur les `FKs` -> √©norme gain de performance pour `Meetings.deleteAll()`
	
- Lock sur la m√©thode utiliser pour r√©cup√©rer les `User.m_id is null` au d√©but de `OrganizeMeetings`:
	- Permet de faire un bricolage de concurrence
	- Met une requ√™te en attente lorsque de deux demandes de `Organize` sont faites au m√™me moment, ce qui √©vite d'avoir des `User` dans deux `Meeting`
	
- Blocage du clic multiplies par le m√™me utilisateur sur `Organize` dans le front pour √©viter le spam sur l'endpoint tant que `Organize` est encore en cours
	- Ajout d'un reload des donn√©es apr√®s appel √† l'endpoint :
		- Permet au `n-ieme (n > 1)` utilisateur de r√©cup√©rer les donn√©es apr√®s la cr√©ation des meetings par le premier utilisateur
	

---

## üìö Connaissances acquises

- `PostreSQL` ne fait pas de cr√©ation automatique d'indexes sur les `foreign keys` des tables
	
- `SSE` pour envoyer des donn√©es par waves au front.
	
- Lock sur les `Quera` dans les `Spring Data JPA`
	

---

## üêû Probl√®mes rencontr√©s

- Bug duplication des r√©unions si l'on appuie plusieurs fois sur organize durant le calcul
	
- Le Query JPA ne supporte pas au dessus de 70 000 rows
	
---

## üîú √Ä faire demain

- Feedback durant `OrganizeMeetings` pour ne pas avoir simplement une attente (+/- longue en fonction du nombre de `Users`)
	
- Message temporaire : reset `timeout` lorsque l'on rappuie
	
- Regarder duplication de code des diff√©rentes m√©thodes de load des pages
	 - Possibilit√© de faire une m√©thode g√©n√©rique param√©tr√© ?
	

---

## üß© Notes / Code

```java
// LinkRepository

@Query(value = """   
    select * from links l  
    where (:isAvailable = true and l.meeting_id is null)    or (:isAvailable = false and l.meeting_id is not null)    """, nativeQuery = true)  
Page<Link> findAllByIsAvailable (@Param("isAvailable") boolean isAvailable, Pageable pageable);


// LinkMapper

public static LinkResponseDto toLinkResponseDto(Link link) {  
  boolean isAvailable = link.getMeetingId() == null;  
  return new LinkResponseDto(  
      link.getId(),  
      link.getLink(),  
      isAvailable,  
      link.getLastReset()  
  );  
}
```

```SQL
explain analyze delete from meetings;
```
```txt
# Suppression avec indexes sur les FKs

                                                  QUERY PLAN
---------------------------------------------------------------------------------------------------------------
 Delete on meetings  (cost=0.00..86.95 rows=0 width=0) (actual time=3.325..3.326 rows=0 loops=1)
   ->  Seq Scan on meetings  (cost=0.00..86.95 rows=3995 width=6) (actual time=0.019..0.577 rows=5000 loops=1)
 Planning Time: 0.163 ms
 Trigger for constraint mails_meeting_id_fkey: time=14.293 calls=5000
 Trigger for constraint fk_meetinguser: time=78.740 calls=5000
 Trigger for constraint fk_meetinglink: time=39.480 calls=5000
 Execution Time: 136.424 ms
(7 rows)
```

```java
@Lock(LockModeType.PESSIMISTIC_READ)  
List<User> findUsersByMeetingIdIsNull ();
```
