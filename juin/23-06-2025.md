## ‚úÖ T√¢ches effectu√©es

- Adaptation du nom de domaine √† la configuration finale.
    
- V√©rification de la pr√©sence de l‚Äôutilisateur dans l‚ÄôActive Directory ainsi que la disponibilit√© du champ `mail`.
    
- Analyse et gestion des nouveaux messages d‚Äôerreurs li√©s √† la recherche du champ `mail`.
    
- Tentatives d‚Äôimpl√©mentation de la connexion s√©curis√©e LDAPS (port 636) pour les √©changes avec l‚ÄôAD.
    

---

## üìö Connaissances acquises

- Les erreurs sur le port 389 sont li√©es √† des probl√®mes d‚Äôautorisation (droits d‚Äôacc√®s √† l‚ÄôAD) plut√¥t qu‚Äô√† une erreur de code.
    
- La configuration LDAPS est plus complexe √† mettre en place, n√©cessitant notamment :
    
    - L‚Äôactivation et la configuration du service LDAPS sur Samba AD (certificats TLS, √©coute sur le port 636).
        
    - La v√©rification que le backend Docker peut r√©soudre le hostname `samba-ad` et joindre le port 636.
        
- L‚Äôerreur `Connection refused` sur LDAPS provient tr√®s probablement d‚Äôun service Samba AD non joignable sur le port 636, soit parce que LDAPS n‚Äôest pas activ√©, soit √† cause d‚Äôun probl√®me r√©seau (r√©solution DNS, r√©seau Docker, firewall).
    

---

## üêû Probl√®mes rencontr√©s

- Complexit√© de la configuration et activation correcte de LDAPS sur Samba AD, notamment :
    
    - Mise en place des certificats TLS n√©cessaires.
        
    - Assurance que le port 636 est bien expos√© et √©cout√© dans le container.
        
    
- Probl√®mes de r√©solution DNS ou de r√©seau Docker emp√™chant le backend de joindre `samba-ad` sur le port LDAPS.
    
- Autorisations insuffisantes dans l‚ÄôAD lors des requ√™tes LDAP non s√©curis√©es.
    

---

## üîú √Ä faire demain

- Finaliser la configuration et l‚Äôactivation de LDAPS :
	
	- Contexte uniquement pour le changement de mot de passe pour √©viter de tous casser
	

---

## üß© Notes / Code

```java
# OpenLdapService

public LdapUserLookupResult checkUserAndMail(String openldapId) {  
  EqualsFilter filter = new EqualsFilter(uidAttribute, openldapId.trim());  
  try {  
    List<LdapUserLookupResult> results = ldapTemplate.search(  
        ldapBaseDn,  
        filter.encode(),  
        (AttributesMapper<LdapUserLookupResult>) attrs -> {  
          if (attrs.get(mailAttribute) != null) {  
            return LdapUserLookupResult.FOUND_WITH_MAIL;  
          } else {  
            return LdapUserLookupResult.FOUND_WITHOUT_MAIL;  
          }  
        }  
    );  
    return results.isEmpty() ? LdapUserLookupResult.NOT_FOUND : results.get(0);  
  } catch (Exception e) {  
    logger.error("Erreur lors de la recherche LDAP pour {}: {}", openldapId, e.getMessage());  
    return LdapUserLookupResult.NOT_FOUND;  
  }  
}  
  
public Optional<String> getMail (String openldapId) {  
  EqualsFilter filter = new EqualsFilter(uidAttribute, openldapId.trim());  
  try {  
    return ldapTemplate.search(ldapBaseDn, filter.encode(),  
        (AttributesMapper<String>) attrs -> {  
          Attribute mail = attrs.get(mailAttribute);  
          return mail != null ? mail.get().toString() : null;  
        }).stream().filter(Objects::nonNull).findFirst();  
  } catch (Exception e) {  
    return Optional.empty();  
  }  
}
```

```java
# Controller

  
@PostMapping("/generate")  
public ResponseEntity<?> generateToken(@RequestBody String openldapId) {  
  
  if (openldapId == null || !openldapId.matches("^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$")) {  
    return ResponseEntity.status(HttpStatus.BAD_REQUEST)  
        .body(Map.of("message", "Adresse e-mail invalide."));  
  }  
  
  LdapUserLookupResult result = openLdapService.checkUserAndMail(openldapId);  
  return switch (result) {  
    case NOT_FOUND -> {  
      logger.warn("Utilisateur {} introuvable dans Samba-AD.", openldapId);  
      yield ResponseEntity.status(HttpStatus.NOT_FOUND)  
          .body(Map.of("message", "Utilisateur introuvable dans Samba-AD."));  
    }  
    case FOUND_WITHOUT_MAIL -> {  
      logger.warn("Utilisateur {} trouv√© mais sans champ mail.", openldapId);  
      yield ResponseEntity.status(HttpStatus.NOT_FOUND)  
          .body(Map.of("message", "Utilisateur sans mail dans Samba-AD."));  
    }  
    case FOUND_WITH_MAIL -> {  
      String mail = openLdapService.getMail(openldapId).orElseThrow();  
      yield processPasswordReset(openldapId, mail, false);  
    }  
  };  
}
```